# --- Import required libraries ---
# FastAPI for building the web API
from fastapi import FastAPI, HTTPException, Query

# Pydantic for data validation (helps us define input/output schemas)
from pydantic import BaseModel, Field

# Typing helps define structured input types (lists, optionals, etc.)
from typing import List, Optional

# datetime is used to store the time of each detection
from datetime import datetime

# Import our database connection and model definition
from database import database
from model import new_detections


# --- Initialize the FastAPI app ---
# The title will appear in the Swagger documentation at http://localhost:8000/docs
app = FastAPI(title="Dust Detection DB API")


# --- Pydantic Schemas ---
# These define how data sent to (and returned from) the API should look.

class DetectionIn(BaseModel):
    """Schema for incoming detection data (client → API)"""
    filename: str  # e.g., 'frame_000.jpg'
    bbox: List[int] = Field(..., min_items=4, max_items=4)  # bounding box [x, y, w, h]
    confidence: float = Field(..., ge=0.0, le=1.0)  # detection confidence between 0 and 1
    timestamp: datetime  # when detection happened

class DetectionOut(DetectionIn):
    """Schema for data returned by the API (API → client)"""
    id: int  # unique identifier (auto-generated by the database)


# --- Event handlers ---
# These functions connect/disconnect to the database automatically
@app.on_event("startup")
async def startup():
    """Connect to the database when the app starts"""
    await database.connect()

@app.on_event("shutdown")
async def shutdown():
    """Disconnect from the database when the app stops"""
    await database.disconnect()


# --- POST Endpoint: Add a new detection ---
@app.post("/detections", response_model=DetectionOut)
async def create_detection(det: DetectionIn):
    """
    Create a new detection record in the database.
    Example body (JSON):
    {
        "filename": "frame_001.jpg",
        "bbox": [100, 150, 80, 60],
        "confidence": 0.92,
        "timestamp": "2025-10-15T15:30:00"
    }
    """
    try:
        # Insert the record into the database
        query = new_detections.insert().values(**det.dict())

        # Execute the query and return the new record’s ID
        det_id = await database.execute(query)

        # Return the full record (id + the input fields)
        return {"id": det_id, **det.dict()}

    except Exception as e:
        # If something goes wrong (like DB connection issues)
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


# --- GET Endpoint: Retrieve detections ---
@app.get("/detections", response_model=List[DetectionOut])
async def read_detections(
    min_confidence: float = Query(0.0, ge=0.0, le=1.0),  # filter by confidence
    filename: Optional[str] = None  # optionally filter by filename
):
    """
    Retrieve all detections, filtered by confidence and/or filename.
    Example:
    - /detections?min_confidence=0.8
    - /detections?filename=frame_001
    """
    # Base query: select rows where confidence >= min_confidence
    query = new_detections.select().where(new_detections.c.confidence >= min_confidence)

    # Optional filter: match filenames containing a given string
    if filename:
        query = query.where(new_detections.c.filename.ilike(f"%{filename}%"))

    # Run the query and return all results
    results = await database.fetch_all(query)
    return results